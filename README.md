# Fund_Labs_4semestr
 | Lab | Mark |
| ------ | ------ |
| lab6.1 | Not ready yet |
| lab6.2 | Not ready yet |
| lab7 | Untested |
| lab8 | Untested |

# lab6

## 0 

Опишите абстрактный класс **TeX_convertible**, содержащий единственную чистую виртуальную функцию с прототипом **std::string convert() const;**
, задачей которой является преобразование вызывающего объекта, тип которого наследует TeX_convertible, 
в строку с кодом на TeX, который при компиляции порождает математическую форму записи этого объекта.

## 1. 

Разработайте класс квадратной матрицы, наследующий класс **TeX_convertible.**
Класс должен содержать указатель на место в памяти, где располагаются элементы матрицы (вещественного типа данных) и её размерность (целое неотрицательное число). 
Для класса реализуйте необходимое число конструкторов (при этом хотя бы один из них должен принимать аргументы по умолчанию); 
перегрузите конструктор копирования; деструктор; оператор присваивания; арифметические операторы для сложения матриц, вычитания матриц, умножения матриц, 
умножения матрицы на число и числа на матрицу; операторы сравнения матриц на предмет полного равенства (epsilon принять равным 1e-6); 
индексатор для взятия значения из матрицы по индексам строки/столбца (отсчёт с 0); операторы вставки в поток и выгрузки из потока. 
Реализуйте дружественные методы вычисления определителя, нахождения обратной матрицы, нахождения транспонированной матрицы, 
вычисление следа матрицы и матричной экспоненты выполнения операции, должна быть сгенерирована исключительная ситуация 
(для каждого типа ошибки - свой тип исключительной ситуации), которая должна быть перехвачена и обработана в вызывающем коде. 
Продемонстрируйте работу с вашим классом: на вход программе подаётся файл, 
содержащий выражения с матрицами (каждое из выражений содержит одну из операций: сложение 
/ вычитание / умножение матриц, умножение матрицы на число, умножение числа на матрицу, сравнение матриц (==, !=); 
нахождение определителя матрицы; нахождение обратной матрицы; нахождение транспонированной матрицы; нахождение следа матрицы;
нахождение матричной экспоненты; формат представления данных в файле определите самостоятельно). 
Необходимо вычислить значения всех выражений и сгенерировать *TeX-файл* 
(выражения, при вычислении которых была сгенерирована исключительная ситуация, в выходной файл выписываться не должны), 
где каждое выражение будет иметь вид <исходное выражение> = <результат вычисления выражения>. 

>(optional) После генерации TeX-файла необходимо запустить его компиляцию и получить на выходе pdf-файл. 

>*Замечания*. Арифметические операции необходимо реализовать с помощью соответствующих операции присваивания:
например, операция + должна быть реализована с помощью операции +=. 
Необходимо продемонстрировать передачу аргументов в функции по значению и по ссылке; 
возврат объекта из функции.

## 2.


 Реализовать immutable-класс монома от нескольких переменных,
наследующий класс TeX_convertible. Класс должен содержать набор
уникальных однобуквенных имён переменных, соответствующие
именам переменных степени (целое неотрицательное число) и
коэффициент (целое число). В классе монома должны быть
определены и реализованы следующие сущности:
\newlne
● Конструкторы (обязателен конструктор, принимающий на
вход строковое представление монома (типа char*); также
обязателен перегруженный конструктор копий);
● Перегруженный деструктор;
● Перегруженный оператор присваивания;
● Перегруженные операторы для арифметических операций
между мономами: +, +=, -, -=, *, *=;
● Перегруженные операторы для взятия частной производной
монома: /, /= (параметр типа char);
● Перегруженные операторы для сравнения мономов на
предмет полного равенства: ==, !=;
● Перегруженные операторы вставки в поток и выгрузки из
потока для корректного вывода/ввода монома.
На основе реализованного класса монома необходимо
реализовать класс полинома от нескольких переменных (также
наследующий класс TeX_convertible). Класс полинома должен
представлять собой контейнер мономов на базе двусвязного списка;
в произвольный момент времени в полиноме не должны
присутствовать мономы, равные без учёта коэффициентов, а также
мономы с коэффициентом, равным нулю. В классе полинома
необходимо реализовать:
● Конструкторы (обязателен конструктор, принимающий на
вход строковое представление полинома (типа char*); также
обязателен перегруженный конструктор копий);
● Перегруженный деструктор;
● Перегруженный оператор присваивания;
● Перегруженные операторы для арифметических операций
между полиномами: +, +=, -, -=, *, *=;
● Перегруженные операторы для взятия частной производной
полинома: /, /= (параметр типа char);
● Перегруженные операторы для взятия смешанной (по
нескольким переменным) производной полинома: /, /=
(параметр типа char* - строка с именами переменных);
● Перегруженные операторы для сравнения полиномов: ==,
!=;
● Перегруженные операторы вставки в поток и выгрузки из
потока для корректного ввода/вывода полинома;
● Дружественный метод для проверки полинома на
однородность;
● Дружественный метод для проверки полинома на
гармоничность.
Для демонстрации работы класса полинома реализуйте
возможность обработки входного файла, содержащего выражения с
полиномами (каждое выражение содержит одну из операций:
сложение/вычитание/умножение полиномов; нахождение
смешанной производной по строке с именами переменных;
сравнение полиномов (==, !=); проверка полинома на однородность;
проверка полинома на гармоничность; формат представления
данных в файле определите самостоятельно). Необходимо
вычислить значения всех выражений и сгенерировать TeX-файл, где
каждое выражение будет иметь вид
<исходное выражение> = <результат вычисления выражения>.
>(optional) После генерации TeX-файла необходимо запустить его
компиляцию и получить на выходе pdf-файл.
Замечания. Арифметические операторы необходимо
реализовать с помощью соответствующих арифметических операций
с присваиванием (например, оператор + должен быть реализован с
помощью оператора +=). Продемонстрировать передачу аргументов
в функции по значению и по ссылке.

